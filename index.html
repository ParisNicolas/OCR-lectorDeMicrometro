<!DOCTYPE html>
<html lang="es">
<head>

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <meta charset="UTF-8">
  <title>OCR con zona de captura</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.0.1/dist/tesseract.min.js"></script>
</head>
<body class="bg-gray-100 p-4 font-sans">

  <div class="flex flex-col w-full max-w-lg mx-auto px-2">
    <div class="bg-white rounded-lg shadow-md overflow-hidden">
      <!-- Vista de c√°mara -->
      <div id="video-container" class="relative bg-black w-full aspect-[4/3] flex items-center justify-center">
        <video id="video" class="absolute w-full h-full object-cover" autoplay playsinline></video>

        <!-- Zona de recorte editable (movible y redimensionable) -->
        <div id="crop-area"
             class="absolute border-2 border-yellow-400 bg-yellow-200 bg-opacity-20 resize rounded"
             style="top: 40px; left: 40px; width: 160px; height: 80px; cursor: move; overflow: auto; z-index: 20;">
        </div>

        <!-- Overlay con texto OCR -->
        <div id="overlayText" class="absolute top-2 right-2 bg-black bg-opacity-70 text-white px-3 py-1 rounded-full text-lg font-bold z-30">
          ...
        </div>

        <!-- Preview canvas in video container -->
        <canvas id="previewCanvas" class="absolute bottom-1 left-1 z-30 border border-white rounded shadow-lg" style="width: 100px; height: 50px;"></canvas>

        </div>
    </div>

    <!-- Controls panel -->
    <div class="mt-4 bg-white rounded-lg shadow-md overflow-hidden">
      <button onclick="toggleControls()" class="w-full bg-gray-50 p-3 text-left font-medium flex justify-between items-center">
        <span>Selection Controls</span>
        <span id="controlsArrow">‚ñº</span>
      </button>
      <div id="controlsPanel" class="p-4">
        <div class="space-y-4">
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-1">Width</label>
            <input type="range" id="widthSlider" min="50" max="300" value="160" class="w-full">
            <div class="text-xs text-gray-500 mt-1" id="widthValue">160px</div>
          </div>
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-1">Height</label>
            <input type="range" id="heightSlider" min="50" max="200" value="80" class="w-full">
            <div class="text-xs text-gray-500 mt-1" id="heightValue">80px</div>
          </div>
        </div>
      </div>
    </div>
  </div>



      <!-- Info del proceso -->
      <div class="p-3">
        <div class="flex justify-between items-center mb-3">
          <div class="text-lg font-bold">Chapa: <span id="chapa">1</span></div>
          <div class="bg-blue-100 text-blue-800 px-3 py-1 rounded-full text-sm" id="tipo">Galvanizado</div>
        </div>

        <div class="bg-gray-100 p-3 rounded-lg mb-4">
          <div class="flex justify-between mb-2">
            <span class="text-gray-600">Lecturas:</span>
            <span id="lecturas" class="font-mono">0/6</span>
          </div>
          <div class="flex justify-between mb-2">
            <span class="text-gray-600">Promedio:</span>
            <span id="promedio" class="font-mono font-bold">-</span>
          </div>
          <div class="flex justify-between">
            <span class="text-gray-600">Desviaci√≥n:</span>
            <span id="desviacion" class="font-mono">-</span>
          </div>
        </div>
        <!-- Lista din√°mica de lecturas -->
        <div id="listaLecturas" class="flex flex-wrap gap-2 mb-4"></div>

        <!-- Botones -->
        <div class="grid grid-cols-2 gap-3">
          <button onclick="setTipo('G')" class="bg-gray-200 p-4 rounded-lg flex flex-col items-center touch-manipulation">
            <div class="text-sm">Galvanizado</div>
            <div class="font-bold">G</div>
          </button>
          <button onclick="setTipo('B')" class="bg-gray-200 p-3 rounded-lg flex flex-col items-center">
            <div class="text-sm">Base</div>
            <div class="font-bold">B</div>
          </button>
          <button onclick="cambiarChapa(-1)" class="bg-gray-200 p-3 rounded-lg flex flex-col items-center">
            <div class="text-sm">-1</div>
            <div class="font-bold">‚Üì</div>
          </button>
          <button onclick="cambiarChapa(1)" class="bg-gray-200 p-3 rounded-lg flex flex-col items-center">
            <div class="text-sm">+1</div>
            <div class="font-bold">‚Üë</div>
          </button>
        </div>
      </div>
    </div>

    <!-- Barra inferior -->
    <div class="mt-4 bg-white rounded-lg shadow-md p-3 flex justify-around">
      <button class="p-2 text-blue-600"><div class="flex flex-col items-center">üìä<div class="text-xs">Stats</div></div></button>
      <button onclick="capturarYLeer()" class="p-2 text-blue-600"><div class="flex flex-col items-center">üì∑<div class="text-xs">Capture</div></div></button>
      <button class="p-2 text-blue-600"><div class="flex flex-col items-center">üíæ<div class="text-xs">Export</div></div></button>
      <button class="p-2 text-blue-600"><div class="flex flex-col items-center">‚öôÔ∏è<div class="text-xs">Settings</div></div></button>
    </div>
  </div>

  <!-- Hidden canvas for processing -->
  <canvas id="canvas" class="hidden"></canvas>


  <script>
    // Elementos del DOM
    const listaLecturas = document.getElementById('listaLecturas');
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const overlayText = document.getElementById('overlayText');
    const ctx = canvas.getContext('2d');
    const widthSlider = document.getElementById('widthSlider');
    const heightSlider = document.getElementById('heightSlider');
    const cropArea = document.getElementById('crop-area');

    //Variables de estado
    const cantidadLecturas = 6;
    let chapa = 1, tipo = 'G';
    let resultados = [{'G':undefined, 'B':0.0}];
    let lecturas = [{'G':[], 'B':[]}];

    // Drag and drop para la zona de recorte
    let isDragging = false;
    let startX, startY, initialX, initialY;

    // Acceder a la c√°mara
    navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } })
    .then(stream => video.srcObject = stream)
    .catch(err => alert('Error al acceder a la c√°mara'));

    // Reconocimiento de texto
    function capturarYLeer() {
      const vw = video.videoWidth;
      const vh = video.videoHeight;
      canvas.width = vw;
      canvas.height = vh;

      ctx.drawImage(video, 0, 0, vw, vh);

      // Coordenadas relativas de la zona de recorte
      const cropRect = cropArea.getBoundingClientRect();
      const videoRect = video.getBoundingClientRect();

      // Convertir de px de pantalla a coordenadas del canvas/video
      const scaleX = vw / videoRect.width;
      const scaleY = vh / videoRect.height;

      const cropX = (cropRect.left - videoRect.left) * scaleX;
      const cropY = (cropRect.top - videoRect.top) * scaleY;
      const cropW = cropRect.width * scaleX;
      const cropH = cropRect.height * scaleY;

      const cropped = ctx.getImageData(cropX, cropY, cropW, cropH);

      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = cropW;
      tempCanvas.height = cropH;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.putImageData(cropped, 0, 0);

      // Preprocessing for better OCR
      const imageData = tempCtx.getImageData(0, 0, cropW, cropH);
      const data = imageData.data;

      // Convert to grayscale and increase contrast
      for (let i = 0; i < data.length; i += 4) {
        const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
        // Increase contrast
        const contrast = 1.5; // Adjust this value to increase/decrease contrast
        const factor = (259 * (contrast + 255)) / (255 * (259 - contrast));
        const value = factor * (avg - 128) + 128;

        // Threshold
        const threshold = 128;
        const final = value > threshold ? 255 : 0;

        data[i] = data[i + 1] = data[i + 2] = final;
      }

      tempCtx.putImageData(imageData, 0, 0);

      // Show preview
      const previewCanvas = document.getElementById('previewCanvas');
      previewCanvas.width = cropW;
      previewCanvas.height = cropH;
      previewCanvas.getContext('2d').drawImage(tempCanvas, 0, 0);

      overlayText.textContent = "Procesando...";

      Tesseract.recognize(
        tempCanvas,
        'eng',
        {
          logger: m => console.log(m),
          tessedit_char_whitelist: '0123456789.'
        }
      ).then(({ data: { text } }) => {
        const value = parseFloat(text.replace(/[^\d.]/g, ''));
        if (!isNaN(value)) {
          if (value < 30.0 && value > 1.0){
            lecturas[chapa-1][tipo].push(value);
            checkAndChangeType();
            overlayText.textContent = `${value.toFixed(1)} Œº`;
          }else{
            overlayText.textContent = "Fuera de rango";
          }
        } else {
          overlayText.textContent = "No detectado";
        }
      });
    }

    // Funciones de actualizaci√≥n de la UI
    function actualizarStats() {
      let promedio = resultados[chapa-1][tipo];
      let desviacion = Math.sqrt(lecturas[chapa-1][tipo].map(x => (x - promedio) ** 2).reduce((a, b) => a + b, 0) / lecturas[chapa-1][tipo].length);

      document.getElementById('lecturas').textContent = `${lecturas[chapa-1][tipo].length}/${cantidadLecturas}`;
      document.getElementById('promedio').textContent = `${promedio ? promedio.toFixed(1):'-'} Œº`;
      document.getElementById('desviacion').textContent = `¬±${desviacion ? desviacion.toFixed(1):'-'} Œº`;

      listaLecturas.innerHTML = '';
      lecturas[chapa-1][tipo].forEach((val, idx) => {
        const li = document.createElement('spam');
        li.textContent = `${idx + 1}. ${val.toFixed(1)} Œº`;
        li.classList.add('bg-gray-100', 'p-2', 'rounded-lg', 'text-gray-800'); // Tailwind clases para estilo
        listaLecturas.appendChild(li);
      });
    }

    // Funciones de cambio de chapa y tipo
    function checkAndChangeType(){
      //Promediar y actualizar resultados
      resultados[chapa-1][tipo] = lecturas[chapa-1][tipo].reduce((a, b) => a + b, 0) / lecturas[chapa-1][tipo].length;

      if (lecturas[chapa-1][tipo].length === cantidadLecturas){
        if (tipo === 'G'){
          setTipo('B');
        }else{
          cambiarChapa(1);
        }
      }
      actualizarStats();
    }

    function cambiarChapa(delta) {
      if (chapa+delta < 1) return; //Limite inferior
      chapa += delta;
      document.getElementById('chapa').textContent = chapa;

      // Inicializar el objeto de resultados para la nueva chapa si no existe
      if (!resultados[chapa-1]) {
        resultados[chapa-1] = {'G':undefined, 'B':undefined};
        lecturas[chapa-1] = {'G':[], 'B':[]};
      }

      // Actualizar la informaci√≥n de tipo y promedio para la chapa actual
      setTipo('G');
    }

    function setTipo(nuevoTipo) {
      tipo = nuevoTipo;

      element = document.getElementById('tipo');
      if (tipo === 'G'){
        element.textContent = 'Galvanizado';
        element.classList.remove('bg-green-100', 'text-green-800');
        element.classList.add('bg-blue-100', 'text-blue-800');
      }else{
        element.textContent = 'Base';
        element.classList.remove('bg-blue-100', 'text-blue-800');
        element.classList.add('bg-green-100', 'text-green-800');
      }
      actualizarStats();
    }


    actualizarStats();

    cropArea.addEventListener('mousedown', (e) => {
      // Solo mover si no se est√° redimensionando (resizer = esquina)
      if (e.target !== cropArea || e.offsetX > cropArea.clientWidth - 20 && e.offsetY > cropArea.clientHeight - 20) return;

      isDragging = true;
      startX = e.clientX;
      startY = e.clientY;
      const rect = cropArea.getBoundingClientRect();
      const containerRect = document.getElementById('video-container').getBoundingClientRect();
      initialX = rect.left - containerRect.left;
      initialY = rect.top - containerRect.top;
      e.preventDefault();
    });

    document.addEventListener('mousemove', (e) => {
      if (!isDragging) return;

      const dx = e.clientX - startX;
      const dy = e.clientY - startY;

      cropArea.style.left = `${initialX + dx}px`;
      cropArea.style.top = `${initialY + dy}px`;
    });

    document.addEventListener('mouseup', () => {
      isDragging = false;
    });

    widthSlider.addEventListener('input', () => {
      cropArea.style.width = widthSlider.value + 'px';
    });

    heightSlider.addEventListener('input', () => {
      cropArea.style.height = heightSlider.value + 'px';
    });

    // Controls panel toggle
    function toggleControls() {
      const panel = document.getElementById('controlsPanel');
      const arrow = document.getElementById('controlsArrow');
      panel.classList.toggle('hidden');
      arrow.textContent = panel.classList.contains('hidden') ? '‚ñº' : '‚ñ≤';
    }

    // Update value displays
    widthSlider.addEventListener('input', () => {
      document.getElementById('widthValue').textContent = widthSlider.value + 'px';
    });

    heightSlider.addEventListener('input', () => {
      document.getElementById('heightValue').textContent = heightSlider.value + 'px';
    });

    //Touch event listeners for mobile
    cropArea.addEventListener('touchstart', (e) => {
        if (e.target !== cropArea || e.touches[0].offsetX > cropArea.clientWidth - 20 && e.touches[0].offsetY > cropArea.clientHeight - 20) return;
        isDragging = true;
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
        const rect = cropArea.getBoundingClientRect();
        const containerRect = document.getElementById('video-container').getBoundingClientRect();
        initialX = rect.left - containerRect.left;
        initialY = rect.top - containerRect.top;
        e.preventDefault();
    });

    document.addEventListener('touchmove', (e) => {
        if (!isDragging) return;
        const dx = e.touches[0].clientX - startX;
        const dy = e.touches[0].clientY - startY;
        cropArea.style.left = `${initialX + dx}px`;
        cropArea.style.top = `${initialY + dy}px`;
    });

    document.addEventListener('touchend', () => {
        isDragging = false;
    });
  </script>
</body>
</html>